# About Script Engine
이 스크립트 엔진은 "주식게임개발부"에서 작성된 스크립트를 이해하기 위한 인터프리터입니다.


------------

## 게임 시스템 구조
모든 스크립트의 명령의 기본 단위는 Segment입니다.
변수를 설정하거나, 텍스트를 출력하는 등 모든 명령 하나 하나가 Segment라고 할 수 있습니다.

그리고 그런 Segment들이 모인 것을 Segment Set(세그먼트 집합)이라고 부릅니다.

예를 들어, 변수를 저장하고, 이를 출력하는 구문이 모인 것이 하나의 Segment Set입니다.

그리고 이 Segment Set은 게임 스토리의 흐름에서 하나의 에피소드와 같습니다.
예를 들어, 이 게임에서 주식 구매 버튼 클릭 후 실행되는 스크립트 명령들의 집합이 Segment Set과 같습니다.

만약, 주식 구매 버튼을 클릭했을 때, 계좌의 금액에 1이 더해진다면 이는, 계좌 금액 변수에 1을 더하는 Segment 하나로 구성된 Segment Set이 실행된 결과입니다.

이 Segment Set은 여러 개를 만들 수 있습니다. 스토리에 여러 개의 에피소드가 존재하는 것처럼 말이죠. 그리고 특정 구문을 이용해 현재 Segment Set에서 다른 Segment Set으로 이동하는 것도 가능합니다.

------------

## (개발자용) 스크립트 엔진의 작동 원리

이 스크립트 엔진은 크게 Lexer, Parser로 나눌 수 있습니다.

Lexer에서는 스크립트 파일을 한 줄씩 읽어들여 Parser가 이해할 수 있는 형태인 Node 단위로 구문을 분리합니다.

Parser는 Lexer로부터 받은 Node들을 분석하여 이를 실행가능한 형태로 만듭니다. 여기서 실행가능한 형태란, Execute라는 함수만 실행하면 모든게 처리되는 형태를 의미합니다.

이때, 이 "실행가능한 형태"가 Segment입니다. 그리고, 이 해석된 스크립트 구문의 종류에 따라 다양한 Segment들이 만들어집니다. 

그리고 하나의 Segment Set에 속하는 Segment들을 Pipeline이라는 객체에 담는데, 이는 게임 내에서 Segment Set 단위로 스크립트를 실행할 수 있게 하기 위함입니다.

만들어진 Pipeline들은 PipelineHandler에게 전달되고, 이 PipelineHandler가 게임 전체를 관활하는 기능을 갖게 됩니다.

------------

## 스크립트 작성 규칙

### 0. 규칙

각 스크립트 구문은 반드시 한 줄로 작성해야 합니다. 구문 길이가 길어지더라도 엔터를 쳐서 밑으로 내리는 등의 행위는 반드시 해서는 안됩니다.

각 스크립트 구문은 반드시 Segment Set 안에 속해있어야 합니다.

Segment Set은 다음과 같이 지정합니다.

```
segment_set_이름 {

     .
     .
     .
    스크립트 구문들

}
```

### 1. 변수 할당

변수를 할당하는 명령어의 이름은 set_variable입니다. 그리고 그 다음에 {와, } 사이에 원하는 변수 이름과, 변수 값을 "변수 이름" : 변수 값 형태로 끼워넣습니다.

여러 개의 변수를 동시에 할당해야 할 경우, 각 변수 이름-변수 값 사이에 , 를 끼워넣습니다.

또한, 변수의 값으로 1+1, "1" + "1" 등 기본적인 숫자 연산이나, 문자열 합치기 등이 가능합니다.
또, 변수도 사용이 가능합니다. 자세한 것은 2. 변수 사용에서 다룹니다.

예를 들어 gosegu 라는 변수에 1 이라는 값, gosegu_1 이라는 변수에 "바보"라는 값을 넣는 구문은 다음과 같습니다.
```
set_variable { "gosegu" : 1 , "gosegu_1" : "바보" }
```

여기서 1은 정수, "바보"는 문자열을 나타냅니다. 숫자일 경우 1, 1.0 등 정수, 실수형으로 표기하는 한편, 문자열은 따옴표(")로 감싸주어야합니다.

그리고 변수는 항상 전역 변수입니다. 한번 할당한 변수는 게임이 끝날 때까지 절대로 삭제되지 않으며, 어느 스크립트 구문에서든 사용할 수 있습니다.

### 2. 변수 사용

변수를 사용하기 위해서는 단순히 변수 이름 앞에 $ 를 붙여주면 됩니다.
예를 들어 "1. 변수 할당"에서 할당한 "gosegu" 변수 값을 가져오려면 $gosegu 로 표기하면 됩니다.

"1. 변수 할당"에서 gosegu 변수의 값을 불러오고, 이 값과 1을 더한 값을 gosegu2 라는 변수에 저장하는 구문은 다음과 같습니다.

```
set_variable { "gosegu2" : $gosegu + 1 }
```

### 3. 텍스트 출력

텍스트를 출혁하는 명령어의 이름은 print 입니다.

이 명령어는 변수 할당처럼 { } 안에 키:값 쌍을 적어주어야 합니다.

키의 이름에 따라 텍스트가 출력되는 방식이 다릅니다.

1. 주인공(고세구)의 대사를 출력할 경우

키는 gosegu 입니다.

```
print { "gosegu" : "출력할 대사" }
```

현재까지 어떤 인물들이 나오는지는 정확하지 않아 고세구 대사 출력 기능까지만 만들어 둔 상태입니다. 
추후 논의를 통해 print 안에 어떤 키:값 쌍을 넣어서 대사 출력 방식을 정할 건지 정해야합니다.

### 4. 캐릭터 상태 설정

사실 이 기능은 "1. 변수 할당" 기능으로 충분히 대체할 수 있습니다.
다만, 기본 변수에다가 캐릭터 변수까지 추가하게 되면 난잡해질 가능성이 있어, 캐릭터 상태 기능만 따로 분리하였습니다.

이 구문의 명령어 이름은 update_state 입니다.

구문은 다음과 같이 사용합니다.

```
update_state $캐릭터_이름 { "변수 이름" : 변수 값 , ..... }
```

말 그대로 캐릭터 변수를 설정한다고 생각하시면 편합니다.


### 5. Segment Set 이동

현재 Segment Set에서 다른 Segment Set으로 이동합니다.

이 구문의 명령어 이름은 go_to 입니다.

test1 이라는 Segment Set으로 이동하고 싶을 경우, 구문은 다음과 같습니다.

```
go_to "test1"
```

go_to 구무은 현재까지 진행되던 Segment들을 모두 취소하고 해당 이름의 Segment Set으로 넘어갑니다.

### 7. IF - ELSE - ENDIF

이 구문은 특정 조건을 만족했는지 확인합니다.

즉, a > 1 과 같이 여러 조건들을 검사할 수 있습니다.

먼저, if 문이 나왔으면, if 문과 그 자식 구문들의 끝에는 endif가 있어야 합니다. 
즉, 다음과 같습니다.

```
if 조건

.
.
.
스크립트 구문
.
.
endif

```

if 조건에 사용될 수 있는 비교 연산자는 다음과 같습니다.

```
> , <, >=, <=, ==, !=
```

예를 들어, 변수의 값을 비교하는 구문은 다음과 같습니다

```
if $변수 > 10
print { "gosegu" : "변수가 10" }
endif
```

조건이 참이면 바로 아래에 있는 구문들을 실행합니다.

조건이 거짓일 경우를 다루기 위해서는 else를 붙입니다.

```
if $변수 > 10
print { "gosegu" : "변수가 10보다 크다" }
else
print { "gosegu" : "변수가 10보다 작거나 같다" }
endif
```

### 7. 선택지 생성

비주얼 노벨의 핵심은 선택지입니다. 선택지를 만드는 과정은 선택지 화면 생성 > 선택지 추가 > 선택지 선택 후 실행될 구문 등록 순으로 이어집니다.

1. 선택지 화면 생성

선택지 화면은 다음과 같이 생성합니다.

```
create_action_selector $선택지화면이름 "선택지 화면에서 표시될 제목"
```

2. 선택지 추가

선택지는 다음과 같이 추가합니다. 선택지가 추가되는 순으로 실제 선택지 화면에서도 선택지가 나열됩니다.

```
create_action $선택지화면이름.선택지 "선택지에 표시될 문장"
```

여기서 주의하실 것은 반드시 $선택지화면이름.선택지 형태를 지켜주셔야한다는 것입니다. 절대로 . 를 빼먹으셔서는 안됩니다.


3. 선택지 선택 후 실행될 구문 등록

```
bind_callback $선택지화면이름.선택지 { 실행될 구문 }
```

"실행될 구문"에 앞서 설명했던 변수 할당 등 스크립트 구문을 넣으시면 됩니다.
여기서 주의하실 것은 반드시 $선택지화면이름.선택지 형태를 지켜주셔야한다는 것입니다. 절대로 . 를 빼먹으셔서는 안됩니다.
위 구문이 실행되는 순서대로 "실행될 구문"들이 실행됩니다.


4. 선택지 화면 띄우기

```
show_action_selector $선택지화면이름
```
### 6. 나머지는 어디갔나요?

제 생각으로는 배경 음악, 배경 이미지 전환 등 기타 기능이 필요한 거 같은데, 생각해보면 이건 print의 키:값 쌍으로 넘겨줘도 무방이라 고민 중입니다.
